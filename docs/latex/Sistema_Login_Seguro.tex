\documentclass[12pt,a4paper]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{hyperref}

\geometry{margin=2.5cm}
\setstretch{1.15}

% Fuente sans serif tipo Arial/Helvetica
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

\title{Sistema de Login Seguro}
\author{Santiago Barron, Candela Castillo, Facundo Vulcano}
\date{}

\begin{document}

\maketitle

\section{Introducción y alcance}

El objetivo de este trabajo es diseñar un sistema de autenticación web seguro para una aplicación web mínima de gestión de usuarios. El foco no está en la funcionalidad de negocio de la aplicación, sino en la seguridad del proceso de autenticación, abarcando registro de usuarios, inicio y cierre de sesión, gestión de sesiones, rotación y renovación de tokens, y cambio de contraseña.

El diseño propuesto integra hashing seguro de contraseñas, gestión de sesiones basada en tokens JWT con \emph{access tokens} de corta duración y \emph{refresh tokens} con rotación obligatoria y revocación, controles preventivos de seguridad (por ejemplo, protección frente a fuerza bruta y CSRF) y políticas explícitas de privacidad, minimización de datos y retención/borrado.

\section{Requisitos del sistema}

\subsection{Requisitos funcionales}

En cuanto al \textbf{registro de usuario}, el sistema debe permitir crear una cuenta a partir de un correo electrónico válido y verificable, una contraseña y un conjunto mínimo de datos de perfil (como, por ejemplo, el nombre del usuario). Es requisito que el correo electrónico no se encuentre previamente registrado y que las contraseñas se almacenen únicamente como hashes seguros, sin conservar nunca el valor en claro.

En el \textbf{proceso de login}, el usuario debe poder autenticarse mediante correo electrónico y contraseña. Cuando las credenciales son correctas, el sistema emite un access token JWT de corta duración y un refresh token JWT de mayor duración, que se devuelven al cliente mediante cookies seguras marcadas como \texttt{HttpOnly}. En caso de credenciales inválidas, la respuesta debe ser un mensaje genérico de error, sin indicar cuál de los datos falló, para no filtrar información innecesaria.

El sistema debe ofrecer un mecanismo de \textbf{logout} que permita invalidar la sesión del usuario. Para ello se define un endpoint de cierre de sesión que anula el refresh token asociado (marcándolo como revocado en el servidor) y hace expirar las cookies de sesión en el cliente, de modo que no puedan reutilizarse.

Respecto al \textbf{refresh y la rotación de tokens}, se expone un endpoint dedicado, por ejemplo \texttt{/auth/refresh}, que recibe el refresh token desde una cookie \texttt{HttpOnly}. Dicho token se valida comprobando su firma, fecha de expiración y estado (es decir, que no haya sido revocado ni reutilizado). Si la validación es exitosa, el sistema emite un nuevo par de tokens (access y refresh), revoca el refresh token anterior y registra el nuevo en la base de datos. Un refresh token reutilizado debe considerarse comprometido y, en consecuencia, ser rechazado y revocado.

El sistema incluye un flujo de \textbf{cambio de contraseña} accesible sólo para usuarios autenticados. Para completar este flujo, el usuario debe proporcionar su contraseña actual y la nueva contraseña deseada. La aplicación verifica la contraseña actual, valida que la nueva cumpla los requisitos mínimos de complejidad y actualiza el hash almacenado. Como medida de seguridad adicional, se revocan todos los refresh tokens activos del usuario, forzando el cierre de sesión en todos los dispositivos.

Finalmente, se prevé una \textbf{gestión de bloqueo y recuperación}. Ante múltiples intentos fallidos de login, el sistema puede bloquear temporalmente los intentos desde una misma dirección IP o para una misma cuenta, reduciendo el impacto de ataques de fuerza bruta o \emph{credential stuffing}. Opcionalmente se puede incluir un flujo de recuperación de contraseña mediante un token de un solo uso enviado al correo del usuario. Todas estas acciones quedan registradas en un módulo de \textbf{auditoría}, donde se guardan eventos como logins exitosos y fallidos, cambios de contraseña, uso de refresh tokens y revocación de tokens.

\subsection{Requisitos no funcionales}

Desde el punto de vista de \textbf{seguridad}, el sistema debe emplear algoritmos criptográficos modernos y considerados seguros. Para las contraseñas se adopta un esquema de hashing basado en Argon2id, mientras que los tokens JWT se firman con algoritmos como HS256 o ES256. El diseño contempla protecciones frente a ataques habituales, como fuerza bruta, CSRF, XSS, \emph{session fixation} y reutilización de tokens de refresco, y se apoya en una gestión segura de secretos (claves de firma y posibles \emph{peppers}) mediante variables de entorno y, preferentemente, un gestor de secretos externo.

En términos de \textbf{disponibilidad}, el sistema debe seguir funcionando aun cuando se invaliden conjuntos de tokens, y la verificación de los mismos debe ser lo suficientemente eficiente como para soportar un volumen razonable de peticiones concurrentes. La \textbf{escalabilidad} se garantiza evitando mantener estado de sesión en memoria local de un único servidor; en su lugar, la información relativa a refresh tokens y revocación se almacena en una base de datos central accesible desde todas las réplicas del backend.

La \textbf{mantenibilidad} se favorece mediante una organización modular del código: se distinguen claramente la capa de control (endpoints HTTP), la lógica de autenticación, la capa de persistencia y los componentes de utilidades criptográficas. Sobre estas piezas se construyen pruebas automatizadas para las funciones críticas (hashing y verificación de contraseñas, emisión y verificación de JWT, lógica de rotación de tokens). Por último, la \textbf{privacidad y el cumplimiento} se consideran requisitos transversales: el diseño promueve la minimización de datos personales, la definición de una política clara de retención y la posibilidad de borrar o anonimizar la información del usuario cuando corresponda.

\section{Arquitectura propuesta}

La arquitectura lógica del sistema se compone, en términos generales, de un \textbf{frontend web}, una \textbf{API backend}, una \textbf{base de datos relacional} y un \textbf{gestor de secretos}. El frontend ofrece las interfaces de usuario para registro, inicio de sesión, cambio de contraseña y otras operaciones básicas. Es importante destacar que el frontend no gestiona directamente los tokens de autenticación: en lugar de almacenarlos en almacenamiento local, confía en cookies \texttt{HttpOnly} gestionadas por el navegador, lo que reduce la superficie expuesta a ataques XSS.

El backend expone una serie de endpoints REST, tales como \texttt{/auth/register}, \texttt{/auth/login}, \texttt{/auth/logout}, \texttt{/auth/refresh} y \texttt{/auth/change-password}. Internamente se organiza en servicios o módulos, entre los que se destacan: un servicio de autenticación que implementa la lógica de negocio relacionada con el login y logout; un servicio criptográfico responsable del hashing y la verificación de contraseñas; un servicio de tokens que se ocupa de la emisión, validación y rotación de JWT; y repositorios de acceso a datos para usuarios y tokens. La base de datos almacena la información persistente necesaria, mientras que el gestor de secretos conserva de manera segura las claves de firma de los JWT y, en su caso, el \emph{pepper} utilizado en el hashing de contraseñas.

En cuanto al patrón de autenticación, se adopta el enfoque de \emph{access token} combinado con \emph{refresh token}. El access token es un JWT de vida corta (del orden de algunos minutos) que se utiliza para autorizar las peticiones a recursos protegidos. El refresh token, por su parte, tiene una vida útil más extensa (por ejemplo, varias semanas) y se emplea exclusivamente para obtener nuevos access tokens a través del endpoint de refresco. Ambos tokens se transmiten y almacenan en cookies marcadas como \texttt{HttpOnly} y \texttt{Secure}, con políticas \texttt{SameSite} configuradas de forma apropiada.

\section{Modelo de datos}

El modelo de datos se basa en unas pocas entidades principales. La tabla \texttt{users} contiene la información básica de los usuarios registrados: un identificador primario de tipo UUID, el correo electrónico (definido como campo único e indexado), el hash de la contraseña generado con Argon2id, un posible campo de \texttt{salt} si la implementación lo requiere de forma explícita, un nombre opcional, marcas de tiempo de creación y actualización, un campo de último login y un indicador booleano de si la cuenta está activa. De esta forma se almacena únicamente la información mínima necesaria para autenticar al usuario, evitando mantener la contraseña en claro o datos de perfil excesivamente sensibles.

La gestión de los tokens de refresco se realiza a través de la tabla \texttt{refresh\_tokens}, que vincula cada token con un usuario concreto. Esta tabla almacena un identificador interno, el identificador del usuario, un identificador de token (\texttt{token\_id}) que coincide con el claim \texttt{jti} embebido en el JWT, la fecha de emisión, la fecha de expiración, un posible campo de revocación (\texttt{revoked\_at}), una referencia al token que lo reemplaza en caso de rotación (\texttt{replaced\_by}) y, opcionalmente, información sobre el agente de usuario y la dirección IP. Este esquema permite implementar revocación, rotación encadenada y auditoría de sesiones activas.

Para registrar eventos de autenticación se propone la tabla \texttt{auth\_logs}, que almacena un identificador, una referencia opcional al usuario (en caso de que el evento esté asociado a una cuenta existente), el tipo de evento (por ejemplo, login exitoso, login fallido, refresco exitoso o fallido, cambio de contraseña), la marca de tiempo, la dirección IP, el \emph{user agent} y un campo de metadatos en formato JSON. De forma opcional, puede añadirse una tabla \texttt{password\_reset\_tokens} para soportar flujos de recuperación de contraseña mediante enlaces temporales, con campos para el identificador, el usuario asociado, el token (o su hash), la fecha de expiración y el momento de uso.

\section{Flujos principales}

En el \textbf{flujo de registro}, el usuario completa un formulario con su correo, contraseña y, eventualmente, su nombre. El backend valida el formato del correo, la complejidad de la contraseña y la unicidad del correo en la base de datos. A continuación genera un salt criptográficamente seguro y aplica Argon2id para obtener el hash de la contraseña, que se almacena en la tabla \texttt{users} junto con el resto de la información. Opcionalmente se envía un correo de verificación. El sistema responde confirmando el alta de la cuenta, sin iniciar sesión automáticamente para reducir el riesgo en caso de registros abusivos.

En el \textbf{flujo de login}, el usuario envía sus credenciales al endpoint correspondiente. El backend localiza el usuario a partir del correo electrónico y, si la cuenta existe y está activa, aplica el mismo esquema de hashing a la contraseña recibida y compara el resultado con el hash almacenado. Una coincidencia válida y la ausencia de bloqueos por intentos fallidos permiten generar un access token JWT con un claim \texttt{sub} igual al identificador del usuario y una expiración corta, así como un refresh token con un \texttt{jti} único y una expiración más prolongada. El refresh token se registra en la tabla \texttt{refresh\_tokens} y ambos tokens se devuelven mediante cookies seguras. Además, se actualiza el campo de último login y se registra un evento de éxito en la tabla de logs.

Cuando el cliente intenta acceder a un recurso protegido, un middleware de autenticación intercepta la petición, extrae el access token (desde la cookie o el encabezado HTTP), valida su firma, fecha de expiración y claims, y, si es válido, añade el identificador del usuario al contexto de la petición. En caso de que el token haya expirado, el cliente debe recurrir al \textbf{flujo de refresh}, invocando el endpoint \texttt{/auth/refresh}. En este flujo, el backend extrae el refresh token de la cookie, verifica su firma y sus atributos, localiza el registro correspondiente en la base de datos y comprueba que el token no haya sido revocado ni utilizado anteriormente para un refresco. Sólo si todas estas comprobaciones son satisfactorias se emite un nuevo par de tokens, se revoca el anterior y se registra el nuevo en la tabla. Así se garantiza que cada refresh token sólo pueda emplearse una vez, mitigando ataques de \emph{replay} si el token fuera interceptado.

El \textbf{logout} se implementa mediante un endpoint específico que, al ser invocado, obtiene el refresh token asociado a la sesión y lo marca como revocado en la base de datos. En la respuesta, las cookies de autenticación se devuelven con fechas de expiración en el pasado, de forma que el navegador las elimine. Tras este proceso, el cliente ya no puede renovar el access token, y los que sigan vivos expiran de manera natural. Para el \textbf{cambio de contraseña}, el usuario autenticado envía su contraseña actual y la nueva contraseña. El backend verifica la primera, valida la segunda según las políticas de complejidad definidas (longitud mínima, variedad de caracteres, etc.) y, en caso positivo, genera un nuevo hash Argon2id que reemplaza al anterior. Como parte de la operación, se revocan todos los refresh tokens activos del usuario, forzando el cierre de sesión en todos los dispositivos. Un correo de notificación puede completar el flujo como medida adicional de seguridad.

\section{Decisiones relacionadas con criptografía}

El componente central de protección de credenciales es el esquema de \textbf{hashing de contraseñas}. Se elige Argon2id por ser el algoritmo recomendado por el Password Hashing Competition y por su resistencia a ataques de fuerza bruta basados en GPU y hardware especializado. Los parámetros de configuración (como el coste temporal, el uso de memoria y el grado de paralelismo) se ajustan al entorno de despliegue, manteniendo un compromiso razonable entre seguridad y rendimiento. Cada contraseña se combina con un salt aleatorio generado mediante un generador criptográficamente seguro, y opcionalmente con un \emph{pepper} almacenado únicamente en el servidor, de forma que, incluso si la base de datos se ve comprometida, resulte más difícil llevar a cabo ataques offline.

Para los \textbf{JWT}, el sistema utiliza algoritmos de firma como HS256, basados en una clave secreta de alta entropía, o bien esquemas asimétricos como ES256, donde el servidor conserva la clave privada y puede distribuir la clave pública para validación por parte de otros servicios. Los tokens incluyen claims básicos, como el identificador del usuario (\texttt{sub}), la fecha de emisión (\texttt{iat}), la fecha de expiración (\texttt{exp}) y el identificador único del token (\texttt{jti}) en el caso de los refresh. Las claves utilizadas para la firma se gestionan fuera del código fuente, preferentemente en un gestor de secretos o como variables de entorno protegidas.

En lo relativo al \textbf{canal de comunicación}, todo el tráfico entre el cliente y el servidor pasa por HTTPS, requisito necesario para que la marca \texttt{Secure} de las cookies tenga sentido. La generación de salts, identificadores y demás valores aleatorios se apoya en generadores de números pseudoaleatorios criptográficamente seguros, evitando funciones de propósito general no aptas para aplicaciones de seguridad.

\section{Gestión de sesiones}

La gestión de sesiones se basa en la combinación de JWT y cookies seguras. Los tokens se almacenan en cookies marcadas como \texttt{HttpOnly}, lo que impide su lectura desde código JavaScript en el navegador y reduce el impacto potencial de vulnerabilidades XSS. La marca \texttt{Secure} exige que las cookies sólo se envíen sobre conexiones HTTPS, mientras que el atributo \texttt{SameSite} se configura para equilibrar seguridad y usabilidad: valores más laxos para el access token y más estrictos para el refresh token disminuyen el riesgo de ataques CSRF.

Dado que la autenticación se basa en cookies, se puede complementar con un token CSRF adicional para operaciones especialmente sensibles, como el cambio de contraseña o la eliminación de la cuenta, exigiendo que el cliente lo envíe en un encabezado separado. La expiración de los tokens se organiza de manera que los access tokens tengan una vida útil muy limitada, mientras que los refresh tokens se mantienen durante períodos más largos, aunque con rotación obligatoria en cada uso y con la posibilidad de definir un tiempo máximo absoluto de sesión.

La revocación de sesiones se implementa a través de la tabla de refresh tokens. El sistema puede revocar un token concreto (de forma análoga a cerrar sesión en un dispositivo específico) o todos los tokens asociados a un usuario, por ejemplo después de un cambio de contraseña o de un incidente de seguridad. Este mecanismo permite un control fino sobre las sesiones activas sin necesidad de mantener tablas de sesión en memoria ni recurrir a soluciones de \emph{sticky sessions}.

\section{Privacidad: minimización de datos, retención y borrado}

En materia de \textbf{minimización de datos}, el sistema almacena únicamente la información estrictamente necesaria para la autenticación: dirección de correo electrónico, hash de la contraseña y, en su caso, un nombre de referencia. No se guardan direcciones físicas, documentos de identidad ni otros atributos que no resulten relevantes para el propósito del sistema. Los registros de auditoría incluyen sólo el identificador del usuario, la IP, el \emph{user agent} y el tipo de evento, sin incorporar datos personales adicionales.

La \textbf{retención de datos} se define mediante políticas específicas. Los registros de usuarios se conservan mientras la cuenta esté activa y el servicio en uso. Los refresh tokens se eliminan o se anonimizan una vez expirados y pasado un período de gracia razonable, suficiente para fines de auditoría. Los logs de autenticación se mantienen únicamente el tiempo necesario para investigar incidentes de seguridad y analizar patrones de ataque, tras lo cual pueden agregarse o borrarse, por ejemplo con una retención máxima de uno o dos años, en función de los requisitos legales y operativos.

El sistema contempla mecanismos de \textbf{borrado} y anonimización. A petición del usuario, la cuenta puede desactivarse y, si se considera apropiado, los datos personales pueden sustituirse por valores irreversibles, manteniendo sólo la información indispensable para preservar la integridad referencial. En ese momento se revocan todos los tokens activos asociados a la cuenta. Además, procesos periódicos en segundo plano se encargan de eliminar refresh tokens expirados con antigüedad superior a la política definida y de depurar los registros de autenticación más antiguos que la fecha de retención establecida.

\section{Conclusión}

El diseño presentado describe un sistema de login seguro que integra hashing robusto de contraseñas, una gestión de sesiones basada en JWT y cookies seguras, flujos bien definidos para registro, autenticación, refresco de tokens, cierre de sesión y cambio de contraseña, y políticas claras de seguridad y privacidad. En conjunto, estos componentes se alinean con las buenas prácticas recomendadas para aplicaciones web modernas y proporcionan una base sólida para una implementación segura y mantenible.

\end{document}
